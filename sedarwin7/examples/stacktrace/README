stacktrace module

The stacktrace security module is provided as an example of
a policy module useful for debugging.  Loading the policy
module and then performing normal operations will cause the
stacktrace module's functions to be invoked at each MAC
check.  When each function is invoked, it walks backward
up the call stack and saves a trace of how the function
was called into a wired trace buffer in the kernel.
A syscall to control the trace is provided.

User commands are provided to copy the trace from the
kernel buffer into a file system file, and to format
the trace for display, converting numeric locations into
symbolic names and offsets where possible.


Configuration

Currently, reconfiguring the trace is done by editing source
files and rebuilding. There are two configuration variables:
- size of the stacktrace buffer
- action when the buffer fills up

Currently the buffer size comes from the line 
   #define RBSIZE 14000000
in "stacktrace_syscalls.h".  14MB is enough to capture a lot
of tracing, although not the entire system initialization.
On a 1GB system, making the buffer much bigger than this
crashes at startup.

Currently the action when the buffer fills up is set by the
line
   static short global_fullbuffer_action = FULLBUFF_STOP;
in "mac_stacktrace.c". Valid values are
 FULLBUFF_RESET - rest the buffer to empty and keep tracing
 FULLBUFF_STOP  - stop tracing

The source of "mac_stacktrace.c" also contains a table with
an entry for each traceable function.  There is a switch
provided that can disable tracing of certain functions.


Usage

To use the stacktrace module, arrange for it to be loaded at
startup and copy the KEXT to (), and reboot.

If you want a trace of as much system initialization as will
fit in the buffer, all you have to do is copy the trace
buffer to a file and format it.  Getting the system up to
Finder level does on the order of a million security calls;
the 14MB buffer won't hold them all.

The save_trace command can be used to control the trace.
  save_trace -off    stops tracing
  save_trace -on     starts tracing
  save_trace -wrap   causes tracing to wrap when full
  save_trace -stop   causes tracing to stop when full
  save_trace file    copies the trace buffer to a file

Thus, one can capture a trace of MAC calls generated by
a certain command by

  save_trace -off
  save_trace -on
  (command to be tested)
  save_trace binaryfilename

The sec_trace command reads a binary trace file and formats
it.

  sec_trace binaryfilename > tracelist.txt

produces a formatted dump of a binary trace file.  
A header is printed showing the content of the file, e.g.
  740663 calls 648 wraps, max depth 2

showing the number of entries, the number of times the trace
buffer wrapped, and the maximum recursion depth.

Each call on a function produces a listing like

check_port_make_send
  0x125cbcb0 0x0029ceb4 _mac_check_port_make_send+76
  0x125cbd10 0x000196e0 _ipc_right_copyin_check+152
  0x125cbd70 0x00014038 _ipc_kmsg_copyin_header+872
  0x125cbe00 0x00014728 _ipc_kmsg_copyin+40
  0x125cbe50 0x0001b668 _mach_msg_send+136
  0x125cbec0 0x0001ba74 _mach_msg_overwrite_trap+60
  0x125cbf20 0x0001baf4 _mach_msg_trap+28
  0x125cbf70 0x000953f8 _ppcscret+232
  0x125cbfc0 0000000000

where the first line names the function called, and
subsequent lines are the trace, showing the stack pointer
and return pointer, and the return pointer's translation if
available.


Using the trace output

One useful thing to do with the formatted trace is to process
it further for use by a program such as GraphViz.  Depending
on what information you want to emphasize, you may wish to
filter and summarize the trace with various post processors.

Some examples are provided. They were produced with various
text transformations on a trace listing.  Program
"readtrace.pl" is an example program that reads a trace
listing and produces one line per trace, with routine names
separated by vertical bars.  Because a typical trace
contains many identical successive calls, readtrace ouputs
its traces preceded by a repitition count. Program
"transformdot.pl" can be used to transform such a file
into lines to be included in a GraphViz .dot file.

The file "f5psc.dot" is a GraphViz input file from system
initialization, showing paths to our security calls.  Yellow
boxes are security policy ops.  Pink boxes are Darwin
modules that are the origin of calls that end up at a
security policy call. There are 368 separate paths to 46
operations traced, originating from 70 different Darwin
modules, though some of the 70 are also intermediate nodes.
The security ops are labeled with the number of different
paths to them, and the originating modules are labeled with
the number of paths they originate, not counting their
appearance as intermediate nodes.

The file "check_prot_send.dot" shows the results of tracing
a single entry, check_port_send, through initialization.


Future Extensions

- Set configuration info from a file read at startup, rather
  than having to recompile the module and commands.

- Current code is PPC only.

- Devise method to init the table of what functions are
  traced without recompiling.

- Extend to optionally trace arguments and results of calls.
  This would take more space in the wired buffer but might
  enable subtle traces.

- Extend to trace conditionally, based on any of
  - recursion depth
  - specific argument values before or after call
  - computed predicates (e.g. start tracing after the
    fifteenth error returned by open)
