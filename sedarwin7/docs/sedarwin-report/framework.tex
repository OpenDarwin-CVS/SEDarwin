\section{MAC Framework on Darwin}

\subsection{Initialization}

The MAC Framework is initialized very early in the startup process
(after virtual memory but before inter-process communication setup),
so that all Mach and BSD objects that require labels can be correctly
labeled as they are created.  Those parts of the Framework
initialization that rely on BSD features (such as sysctls) are
deferred until the BSD subsystem has been partially initialized.
This second stage initialization occurs immediately before the BSD
process structures are allocated.  Many other BSD features, such
as file systems, are initialized after the process structures (and
therefore the MAC Framework), so the Framework cannot use file
systems during its initialization.

While an early prototype required that security policy modules be
statically compiled into the kernel, the current release has support
for dynamically loaded policy modules.  In both cases, modifications
were made to the Mac OS X boot loader and to the Darwin kernel
itself to support the early loading of security policies.


\subsection{Entry Point Invocation}

The MAC Framework on Darwin uses the same entry point invocation
semantics as the FreeBSD version.  The invocation of a Framework
entry point from a kernel service invokes matching entry points
from the set of registered security policies.  The results from the
matching policy entry points are composed and returned to the kernel
service.  This composition of security checks orders the error codes
returned by the policy modules; essentially all modules must return
a non-error value for the check to ``succeed''.

The Darwin version of the Framework adds a generic access control
entry point, {\tt mac\_check\_service\_access()}. This allows
user space programs to check permissions that are unrelated to any
kernel object.  Named permissions are most useful for IPC-oriented
objects, such as Mach ports or System V message queues. Named
permissions could also be used to replace some of the more obtuse
permission sets, such as POSIX.1e capabilities. More information
about this feature may be found in the API and SEDarwin sections.
XXX - does this really belong here?

\subsection{Extended Attributes}

Within the MAC Framework, mounted file systems are either marked as
single-label or multi-label.  Single-label file systems derive the
label for all files from a label assigned at mount time.  Labels on
single-label file systems may not be modified.  For multi-label file
systems, the file system is responsible for implementing a per-file
source of labels; typically this is implemented as file system
extended attributes.  The distinction is currently made at mount time; if the
file system supports extended attributes or is a non-disk file system (such as devfs), the partition is marked as
multi-label --- in all other cases, it defaults to single-label.

The current prototype, based on Mac OS X 10.3 (Pather), supports
extended attributes through the use of a backing store (file) on
an HFS+ file system.  Extended attribute support was based on earlier
work supporting extended attributes on the FreeBSD UFS file system.
\footnote{Mac OS X 10.4 (Tiger) includes native support for extended attributes.}

Named extended attributes allow metadata to be associated with vnodes
representing files and directories.  Our implementation allows
arbitrary data to be stored and retrieved by name.  The SEBSD and SEDarwin policy modules
use this facility to attach a persistent string-based label with file
objects.

\subsection{Label Management}

The MAC Framework maintains the label and provides per-object entry
points to manage the lifecycle of the object.  Entry points are
provided for allocation, initialization, and destruction/deallocation.
The label structure is an array of ``slots''. Security policy modules
request a slot during registration so that they may manage
policy-specific labels as needed.

Security labels follow the existing allocation and usage cycles that the
kernel uses to manage objects.  For most kernel objects, this lifecyle consists of: allocation, initialization, use, deallocation.  The Framework provides label
management (the binding of labels to kernel objects), but each policy
must allocate and manage it's own policy-specific labels. Policies that
have simple label requirements may simply store a few bytes in each label
structure instead of allocating and managing memory themselves.
While the Framework's label allocation typically occurs at the same
time and with the same locking constraints as the kernel object it is
associated with, policy authors must still be aware of locking and
other restrictions on the use of memory allocators.

One of the ways the MAC Framework passes labels to and from user space
is in the form of text strings.  The Framework provides internalize and
externalize routines to allow policy modules to convert between
internal label representations and externally-visable strings.
user space libraries provide policy-agnostic interfaces to read and
update labels.

Label memory in the Framework is allocated with the
Mach zone allocator {\tt zalloc} to provide appropriately sized allocations.
This allocator was the most appropriate
choice because of the locking constraints around the other allocators.
Also, label memory is needed before the BSD subsystem is initialized, so
BSD allocators cannot be used. Policies can use {\tt zalloc} or {\tt kalloc}
(which is built on top of {\tt zalloc}).

\subsubsection{Label Handles}

The FreeBSD MAC Framework communicates labels to user space programs
using text strings. For multi-user servers (such as window systems
and web servers) wishing to perform their own internal access checks,
performing repeated label to text conversions can be expensive. We
introduce the label handle as an alternative to such repeated
conversions: a kernel object with an attached label. It is different
from ordinary kernel objects (such as files and processes) in that
a user program can create a label handle from any valid label.  That
label may be a string in the correct format or a labeled kernel object
that the user has appropriate rights to access.
For example, the window server could store a label handle in each
window structure, and a label handle in each connection object,
instead of storing label strings and having to perform string parsing
each time an access decision is needed.  Our implementation stores
label handles in the Mach port namespace.

As with other Mach objects (such as tasks), a label handle is
accessed via its kernel port.  Note that the label on the handle's
port is distinct from the underlying label that the handle represents.
In the current implementation, the label handle's port is not used
for actual messaging.  Consequently, the system provides no mechanism
for obtaining the access control label of a label handle's port.
Initally, label handles were not backed by actual ports, but merely
used the port namespace (and {\tt ipc\_right}, {\tt ipc\_entry}
structures).  This was changed when maintaining the support for
an extra type of Mach {\tt ipc\_object} became unwieldly.

A task may request a new label handle from the kernel Security
Server.  The label handle may be created from a string representation
or it may be computed based on a subject, object and service name.
The Security Server is described in detail in the next section.  A
task may also request the label handle of an existing port by using
the labels trailer as described in section XXX.  We do not currently
implement label visibility controls.  All tasks may create label
handles representing any label.  Label handles are never modified
after creation (except for task labels where the handle has no other
references).

\subsection{Login Contexts}

On a Mac OS X system, when the user logs in on the graphical console,
applications are launched on behalf of the user by the (already-running
and privileged) WindowServer process rather than by a session manager
that is run with the user's credentials.  This presents a problem
for labelling as there is no direct parent-child relationship between
processes run by a user logged in to the graphical console.  Since
labels are normally inherited by child processes from their parent,
the spawned processes will inherit the WindowServer's label, not
the user's label.

What is needed is a way to group processes akin to the process group
and terminal session used by POSIX job control but with some extra
capabilities.  Mac OS X supports a ``security context'' which is
unique to each login session\cite{securitycontext}.  However, because
the security context must be explicitly managed by the security
daemon, {\tt securityd}, and is not a kernel construct it is
insufficient for this purpose.

We call our construct a ``login context''.  A login context is a
labelled object and supports the following operations: create, adopt
and orphan.  When a child process is created it is added to the
parent's login context and a MAC Framework entrypoint is called.

We use this mechanism to adopt the WindowServer process into a new
login context created when the user logs in and a way to remove it
from the login context when the user logs out.  When the user logs
in, the appropriate label is stored in the newly created login
context, WindowServer is adopted into the login context and the
normal login process continues.  Now, when WindowServer spawns an
application on behalf of the user, the programs will have the user's
label.  When the user logs out, WindowServer is removed from the
user's login context and a new user may login.  This is accomplished
via a plug-in to the Mac OS X loginwindow program, as described in
the Login section.  For network and non-graphical console logins,
the {\tt pam\_lctx} PAM module creates the login context.

\subsection{Boot Loader}

The Darwin bootloader ({\tt BootX}) is responsible for loading the
kernel and some device drivers, and starting up the system. BootX
understands several file system formats, including ext2 and HFS+,
but had no facility for reading arbitrary data from disk and passing
it to the kernel. Security policies may have associated initialization
data (such as policies, labeling information, or startup mode),
which cannot be read using the normal kernel support for disk devices
and file systems, because the security policy modules are initialized
before the BSD subsystem is initialized and usable.  We extended
BootX to read arbitrary data from disk files and the OpenFirmware
variables, and to pass this data to security policy modules.
